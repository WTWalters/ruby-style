{"name":"davetron5000's Ruby Style Guide","body":"# davetron5000's Ruby Style Guide\r\n\r\n#### These rules should be broken if it increases code clarity or maintainability\r\n\r\n#### First and foremost, use the style of the code you are modifying\r\n\r\n\r\n## Files\r\n\r\n#### One class/module per file\r\n\r\nWhy? _Makes it simpler to locate and organize code_\r\n\r\n\r\n#### Follow Rails conventions in Rails apps\r\n\r\n\r\n\r\n#### For non-Rails apps, code goes in `lib`, stdlib extensions go in `ext`\r\n\r\nWhy? _This is where most Rubyists will expect it, and clearly delineates _your app_ from lib extensions_\r\n\r\n\r\n#### Code for a class/module goes in the lower-cased, snake-cased named file, in a directory structure that matches the module namespaces.  For example, the class `Foo::Bar::Baz` should be in `foo/bar/baz.rb`, relative to `lib` or `ext`\r\n\r\nWhy? _Makes it simpler to locate the code for a given class_\r\n\r\n\r\n#### `Test::Unit` files should go in `test` and be named `class_test.rb`, e.g. to test the class `Foo`, create `test/foo_test.rb`.  \r\n\r\nWhy? _Test dir is then sorted by classname, making it easy to visually scan or auto-complete test names_\r\n\r\n\r\n#### Nest test classes to match modules if you have a large library with a lot of different namespaces\r\n\r\n\r\n\r\n#### Follow RSpec and Cucumber file/dir naming conventions\r\n\r\n\r\n\r\n## Formatting\r\n\r\n#### 2-space indent\r\n\r\nWhy? _this is standard across almost all Ruby code_\r\n\r\n\r\n#### Do not bother aligning arrows, equals, or colons.  If there are so many grouped together, consider restructuring your code\r\n\r\nWhy? _Alignment requires extra work to maintain, and results in hard-to-understand diffs when alignment must change_\r\n\r\n\r\n#### Avoid single-line methods\r\n\r\nWhy? _Single-line methods are harder to change when the method needs an additional line_\r\n\r\n\r\n#### Keep line lengths 80 characters or less unless doing so negatively impacts readability (e.g. for large string literals)\r\n\r\nWhy? _Excessively long lines can be very difficult to read and understand; a low line length encourages keeping things simple_\r\n\r\n\r\n#### Literal arrays or hashes should have a comma after *every* element, includingn the last one\r\n\r\nWhy? _This makes it easier to add elements and reorder elements without having to worry about missing commas_\r\n\r\n\r\n#### For 'options-hash' calls, align keys across multiple lines, one per line, e.g.\r\n\r\nWhy? _This makes it easier to read and modify the options sent to the method_\r\n\r\n```ruby\r\nsome_call(non_option1,non_option2,:foo => \"bar\",\r\n                                  :blah => \"quux\",\r\n                                  :bar => 42)\r\n```\r\n\r\n#### When declaring attributes with `attr_reader` or `attr_accessor`, put one per line\r\n\r\nWhy? _This makes it easier to add new attributres without creating complex diffs.  It also affords documenting what the attributes represent_\r\n\r\n```ruby\r\n# Wrong; hard to modify\r\nattr_accessor :first_name, :last_name, :gender\r\n\r\n# Right; we can easily modify and document\r\nattr_accessor :first_name\r\nattr_accessor :last_name\r\nattr_accessor :gender\r\n```\r\n\r\n#### Literal lists should be on one line or one element per line, depending on length\r\n\r\nWhy? _Two-dimensional data is hard to read and modify._\r\n\r\n\r\n#### `protected` and `private` should be aligned with `class`\r\n\r\nWhy? _No reason, just my personal preference_\r\n\r\n```ruby\r\nclass SomeClass\r\n\r\n  def public_method\r\n  end\r\n\r\nprotected\r\n\r\n  def protected_method\r\n  end\r\n\r\nprivate\r\n\r\n  def private_method\r\n  end\r\nend\r\n```\r\n\r\n#### `protected` and `private` are surrounded by newlines\r\n\r\nWhy? _Visually sets them off_\r\n\r\n\r\n#### A newline after `class` or `module`\r\n\r\nWhy? _Visual clearance_\r\n\r\n\r\n#### A newline after `end` unless it's the string of `end`s for the end of the class/module\r\n\r\nWhy? _I don't get much value from visual clearance for the end blocks that 'close' a class or module_\r\n\r\n\r\n#### class methods should be defined via `def self.class_name` and not inside a `class << self`\r\n\r\nWhy? _This reduces errors caused by moving methods around, and also doesn't require you to scroll up in the class to determine what type of method it is; you can see it instantly_\r\n\r\n\r\n#### when using the return value of an `if` expression, indent the `else` and `end` with the `if`:\r\n\r\nWhy? _This makes it very clear that you are using `if..else..end` as a complex expression and not as a control structure_\r\n\r\n```ruby\r\n# Wrong\r\nresult = if something?\r\n  :foo\r\nelse\r\n  :bar\r\nend\r\n\r\n# Right\r\nresult = if something?\r\n            :foo\r\n         else\r\n            :bar\r\n         end\r\n```\r\n\r\n## Naming\r\n\r\n### Variables\r\n\r\n#### Avoid abbreviations\r\n\r\nWhy? _Abbreviations can clash, require explanation and generally disrupt the flow of things_\r\n\r\n\r\n#### Avoid one-character names\r\n\r\nWhy? _No reason not to be descriptive_\r\n\r\n\r\n#### For non 'primitive' types, use the name of the class, or the name of the class plural if a collection, unless there will be multiple instances in scope, then *do not* follow this convention\r\n\r\nWhy? _When there's no particular specific name for something, using its type makes it easy to remember what the object is_\r\n\r\n```ruby\r\n# Just use the classname\r\ndef routine\r\n  customer = Customer.find(124)\r\n  customers = Customer.find_all_by_gender(\"M\")\r\nend\r\n\r\n# Here we have two lists, so neither should just be \"customers\"\r\ndef other_routine\r\n  males = Customer.find_all_by_gender(\"M\")\r\n  minors = Customer.where('age < ?',18)\r\nend\r\n\r\n# Here we have a very long method that, even though it should be refactored,\r\n# isn't, so we use a more verbose variable name to keep things clear 50 lines in.\r\ndef other_routine\r\n  # tons of code\r\n  male_customers = Customer.find_all_by_gender(\"M\")\r\n  minor_customers = Customer.where('age < ?',18)\r\n  # tons more code\r\nend\r\n```\r\n\r\n#### For procs and lambdas, use a verb as opposed to `foo_proc` or `foo_block`\r\n\r\nWhy? _Procs and lambdas are more like methods and thus should be verbs, since they do something_\r\n\r\n```ruby\r\n# Wrong; the variable has been needlessly \"nounified\" for no real benefit\r\nsaver = lambda { |x| x.save! }\r\n\r\n# Correct; the variable, being a verb, is instantly recognizable as an action\r\nsave = lambda { |x| x.save! }\r\n```\r\n\r\n### Methods\r\n\r\n#### Follow the 'referentially transparent' naming scheme of using `foo` and `foo=` for 'accessors'.\r\n\r\nWhy? _Since Ruby allows the '=' form, using 'get' or 'set' in the names just adds noise_\r\n\r\n\r\n#### Boolean methods end in a question mark\r\n\r\nWhy? _This allows methods that can used in expressions to clearly stand out and makes code more fluent_\r\n\r\n\r\n#### Dangerous methods end in a bang.\r\n\r\nWhy? _This calls out methods whose use should be carefully understood_\r\n\r\n```ruby\r\n# Mutates the object; dangerous on an otherwise immutable object\r\ndef process!\r\n  @processed = true\r\nend\r\n\r\n# Has a side-effect that is not obvious and might not be idempotent\r\ndef render!(output)\r\n  queue_event(:some_event)\r\n  output.puts @content\r\nend\r\n\r\n# Raises an exception on failure, unlike its analog, save, which does not\r\ndef save!\r\n  raise ValidationException unless self.save\r\nend\r\n```\r\n\r\n### Classes And Modules\r\n\r\n#### For non-Rails apps, namespace all classes in a top-level module named for your app or library\r\n\r\nWhy? _Prevents naming clashes when your code is used with other libraries_\r\n\r\n\r\n#### Class names should be comprehensible without their module namespace.\r\n\r\nWhy? _Ensures that classnames are understood everywhere used._\r\n\r\n```ruby\r\n# Wrong; 'Base' is not an accurate classname\r\nclass ActiveRecord::Base\r\nend\r\n\r\n# Good; using the class without its namespaced module doesn't remove any clarity\r\nclass Gateway::BraintreeGateway\r\nend\r\n```\r\n\r\n#### Class names should be nouns\r\n\r\nWhy? _Classes represent things, and things are nouns_\r\n\r\n\r\n#### Non-namespace module names should tend toward adjectives, e.g. `Enumerable`\r\n\r\nWhy? _Modules used as mixins represent a trait or aspect that you want to use to enhance a class.  These are naturally adjectives._\r\n\r\n\r\n#### Namespace module names should tend toward nouns\r\n\r\nWhy? _Using modules just for namespacing is, again, specifying things, which are nouns_\r\n\r\n\r\n## General Style\r\n\r\n#### Avoid 1.9-style hash syntax\r\n\r\nWhy? _This syntax only works if your hash keys are symbols; otherwise you have to use the old syntax.  There's a very limited benefit to the new syntax, and the cost is two ways of doing things, increasing mental overhead when reading/writing code.  Further, for libraries, 1.8 compatibility is nice to achieve_\r\n\r\n\r\n#### For libraries or CLI apps, stick to 1.8-compatible features where possible\r\n\r\nWhy? _Many shops are still on 1.8, and many systems have 1.8 as the default, so there's no reason not to keep 1.8 compatible for code that will be shared_\r\n\r\n\r\n#### Blocks that return a value you intend to use should use curly braces\r\n\r\nWhy? _This visually sets them off, and makes for a cleaner chaning syntax_\r\n\r\n```ruby\r\n# Wrong; calling a method on 'end' is awkward looking\r\nmale_teens = Customers.all.select do |customer|\r\n  customer.gender == :male \r\nend.reject do |man|\r\n  man.age > 19 || man.age < 13\r\nend\r\n\r\n# Right; the chaining and use of the comprehensions is clear\r\nmale_teens = Customers.all.select { |customer|\r\n  customer.gender == :male \r\n}.reject { |man|\r\n  man.age > 19 || man.age < 13\r\n}\r\n```\r\n\r\n#### Blocks that do not return a value or a value you will ignore use `do..end`\r\n\r\nWhy? _These blocks are more control-structures, so `do..end` is more natural.  It sets them off from blocks that produce a useful value_\r\n\r\n\r\n#### Always use parens when calling methods with arguments unless you are coding in a heavy 'DSL Style' bit of code\r\n\r\nWhy? _Parens visually set off the parameters, and reduce confusion about how Ruby will parse the line, making the code easier to maintain_\r\n\r\n```ruby\r\n# Given this code\r\nclass Person\r\n  def self.create(name,status)\r\n    # ..\r\n  end\r\nend\r\nPerson.create 'Dave', :single\r\n# and we change it so that :status is based on a condition\r\n\r\n# Wrong; what does this line do?\r\nPerson.create 'Dave', wife || :single\r\n\r\n# If we used parens from the get go, it's a no brainer\r\nPerson.create('Dave',:single)\r\n# Right; code is clear\r\nPerson.create('Dave',wife || :single)\r\n```\r\n\r\n#### Do not use `else` with an `unless`\r\n\r\nWhy? _the expression becomes too difficult to unwind, just use an `if`_\r\n\r\n\r\n#### Do not use an `unless` for any expression that requires a `||`, `&&`, or `!`.  Either extract to a method or use `if`\r\n\r\nWhy? _`unless` is like putting a giant `!()` around your expression, so it becomes harder and harder to understand what is being tested by adding this.  It's not worth it_\r\n\r\n```ruby\r\n# Wrong; too hard to figure out\r\nunless person.valid? && !person.from('US')\r\n  # doit\r\nend\r\n\r\n# Right; DeMorgan's law simplified this\r\nif !person.valid? || person.from('US')\r\n  # doit\r\nend\r\n\r\n# Better; use a method\r\nunless valid_and_foreign?(person)\r\n  # doit\r\nend\r\n```\r\n\r\n#### Use inline if/unless for 'early-exit' features only\r\n\r\nWhy? _Code can become hard to read when conditions are trailing and complex.  Early-exit conditions are generally simple and can benefit from this form_\r\n\r\n```ruby\r\n# Wrong; too complex\r\nperson.save unless person.from('US') || person.age > 18\r\n\r\n# OK; an early exit\r\nraise \"person may not be nil\" if person.nil?\r\n```\r\n\r\n#### Do not catch `Exception` unless you *really* want to catch 'em all.\r\n\r\nWhy? _`Exception` is the base of *all* exceptions, and you typically don't want to catch memory exceptions and the like.  Catch `StandardError` instead_\r\n\r\n\r\n#### When you must mutate an object before returning it, avoid creating intermediate objects and use `tap`:\r\n\r\nWhy? _Intermediate objects increase the mental requirements for understanding a routine.  `tap` also creates a nice scope in which the object is being mutated; you will not forget to return the object when you change the code later_\r\n\r\n```ruby\r\n# Wrong\r\ndef eligible_person(name)\r\n  person = Person.create(:name => name)\r\n  person.update_eligibility(true)\r\n  person.save!\r\n  person\r\nend\r\n\r\n# Right\r\ndef eligible_person(name)\r\n  Person.create(:name => name).tap { |person|\r\n    person.update_eligibility(true)\r\n    person.save!\r\n  }\r\nend\r\n```\r\n\r\n#### Feel free to chain `Enumerable` calls using simple blocks instead of one complex block that does everything.\r\n\r\nWhy? _The braces syntax encourages clean chaning, and with simple blocks, you can easily follow step-by-step what is being done without having to have a bunch of private methods explaining things._\r\n\r\n\r\n#### Avoid conditionals based on the truthiness or falsiness of a variable.  Use `.present?` or `.nil?` to be clear as to what's being tested\r\n\r\nWhy? _It's a lot clearer when you state exactly what you are testing; this makes it easier to change the code later, and avoids sticky issues like 0 and the empty string being truthy_\r\n\r\n```ruby\r\n# Wrong; intent is masked\r\nif person.name\r\n  # do it\r\nend\r\n\r\n# Right; we can see just what we're testing\r\nif person.name.present?\r\n  # do it\r\nend\r\n```\r\n\r\n#### If your method returns true or false, be sure those are the only values returned.\r\n\r\nWhy? _Returning a 'truthy' value will lead to unintended consequences, and could lead to complex dependencies in your code.  You don't need the hassle_\r\n\r\n\r\n## Design\r\n\r\n#### Classes should do one thing and one thing only\r\n\r\n\r\n\r\n#### If a class has only one method, consider using a lambda or proc instead\r\n\r\nWhy? _A class with one method, especially Doer.do, is just a function, so make it a lambda_\r\n\r\n\r\n#### For a base class with abstract methods, include the methods in the base class and have them raise.\r\n\r\nWhy? _This gives you a single place to document which methods subclasses are expected to implement, and ensures that, at least at runtime, they **are** implemented_\r\n\r\n\r\n#### Avoid instantiating classes inside other classes.  Prefer dependency injection and default parameter values.\r\n\r\nWhy? _This makes it easier to test the classes, but doesn't require Herculean efforts to instantiate classes at runtime:_\r\n\r\n```ruby\r\nclass PersonFormatter\r\n  def format(person)\r\n    # whatever\r\n  end\r\nend\r\n\r\n# Wrong; we are tightly coupled to an implementation and have to use\r\n# crazy mocks to fake this out\r\nclass View\r\n  def render\r\n    # code\r\n    puts PersonFormatter.new.format(person)\r\n    # more code\r\n  end\r\n\r\n\r\n# Correct; Option 1 - constructor injection\r\nclass View\r\n  def initialize(person_formatter=PersonFormatter.new)\r\n    @person_formatter = person_formatter\r\n  end\r\n\r\n  def render\r\n    # code\r\n    puts @person_formatter.format(person)\r\n    # more code\r\n  end\r\nend\r\n\r\n# Correct; Option 2 - setter injection with a sensible default\r\nclass View\r\n  attr_writer :person_formatter\r\n  def initialize(person_formatter)\r\n    @person_formatter = PersonFormatter.new\r\n  end\r\n\r\n  def render\r\n    # code\r\n    puts @person_formatter.format(person)\r\n    # more code\r\n  end\r\nend\r\n```\r\n\r\n#### Don't make methods public unless they are part of the public interface\r\n\r\nWhy? _Public is the way to formally document the contract of your class.  Putting methods that shouldn't be called by others in the public interface is just lazy, and increases maintenance down the road._\r\n\r\n\r\n#### `protected` is likely not correct; only use it for the template method pattern and even then, would a lambda or proc work better?\r\n\r\nWhy? _Protected is used to allow subclasses to call non-public methods.  This implies a potentially complex type hierarchy, which is likely not correct for what you are doing._\r\n\r\n\r\n#### Know the `ClassMethods` pattern for sharing class methods via a module\r\n\r\nWhy? _It's a convienient pattern to add macro-style methods to classes, and is used in Rails source, so will be easily recognizable by others_\r\n\r\n```ruby\r\nmodule Helper\r\n  def self.included(k)\r\n    k.extend ClassMethods\r\n  end\r\n  module ClassMethods\r\n    def strategy(strat)\r\n      @strategy = strat\r\n    end\r\n  end\r\nend\r\n\r\nclass UsesHelper\r\n  include Helper\r\n\r\n  strategy :foo\r\n\r\n  def doit; puts self.strat; end\r\nend\r\n```\r\n\r\n#### Do not use ivars as a way of avoiding method parameters.\r\n\r\nWhy? _Instance variables are a form of global data, and your routines' complexity increases when their input comes from multiple sources.  If the instance variables control flow or logic, pass them in as parameters_\r\n\r\n\r\n#### private methods should be used to make public methods clear; they should avoid reliance on ivars if at-all possible\r\n\r\nWhy? _Private methods that do not rely on instance variables can very easily be extracted to new classes when things get compledx_\r\n\r\n\r\n#### private methods calling more private methods might indicate a second class is hiding inside this class\r\n\r\n\r\n\r\n## Documentation\r\n\r\n### General\r\n\r\n#### Use RDoc instead of YARD or TomDoc\r\n\r\nWhy? _RDoc.info does not support TomDoc, and YARD is way too heavyweight_\r\n\r\n\r\n#### Do not surround class or method names in your project with code blocks\r\n\r\nWhy? _RDoc will link to methods or classes in your project_\r\n\r\n\r\n#### DO surround class or method names from other libraries with code blocks\r\n\r\nWhy? _This makes it clear that you mean a method name or class, because RDoc cannot link outside of your codebase_\r\n\r\n\r\n#### Reserve inline comments for answering 'Why?' questions\r\n\r\nWhy? _Don't restate what the code does, but DO explain why it works the way it does, especially if it does something in a suprising or weird way, from a business logic perspective_\r\n\r\n```ruby\r\n## Wrong; don't explain what the code does, we can read it\r\ndef minor?\r\n  # Check if they are under 19\r\n  self.age < 19\r\nend\r\n\r\n## Right; explain the odd logic so others know it is intentional, with\r\n## a ref for more info as to why\r\ndef minor?\r\n  # For our purposes, an 18-year-old is still a minor.  See\r\n  # ticket XYZ for a more detailed discussion\r\n  self.age < 19\r\nend\r\n```\r\n\r\n### Readme\r\n\r\n#### There should be a README that includes:\r\n\r\nWhy? _Because a README is a nice way to explain what your code is/does_\r\n\r\n\r\n#### The README should explain what the library/app does, in one line\r\n\r\nWhy? _Summarizing things in one line is helpful_\r\n\r\n\r\n#### The README should explain how to install your app/code\r\n\r\nWhy? _Because not everyone knows what needs to be done, even if it's just `gem install`_\r\n\r\n\r\n#### The README should show the simplest example possible of using the library/ap\r\n\r\nWhy? _This, along with the description allows someone to understand your library/app in under a minute_\r\n\r\n\r\n#### A more detailed overview, pointing to key classes or modules\r\n\r\nWhy? _When rendered as RDoc, these classes link to where the user should start reading to get a deeper perspective_\r\n\r\n\r\n#### Additional info for developing with the code\r\n\r\nWhy? _If you want contributions, developers need to know how to work with your code_\r\n\r\n\r\n### Methods\r\n\r\n#### Rubydoc the parameter types and return types\r\n\r\nWhy? _There's no other way to tell what the types are and it's just not nice to hide this info_\r\n\r\n\r\n#### Document all known keys, their types, and their default values for 'options hash' style params\r\n\r\nWhy? _Because it's jerky not to; there's no other way to know what they are_\r\n\r\n```ruby\r\n# Makes a request\r\n#\r\n# url:: url to request\r\n# options:: options to control request:\r\n#           +:method+:: HTTP method to use as a String (default \"GET\")\r\n#           +:content_type+:: Mime type to include as a header, as a String (default \"text/plain\")\r\n#           +:if_modified_since+:: Date for if-modified-since header, default nil\r\ndef request(url,options={})\r\nend\r\n```\r\n\r\n#### Document a method's purpose if it's name alone cannot easily communicate it\r\n\r\nWhy? _Good method names are preferred, but if it's somewhat complex, add a bit more about what the method does_\r\n\r\n\r\n#### Document the meaning of parameter types if their name alone isn't enough to communicate it\r\n\r\nWhy? _Again, the parameter names should be meaninful, but if they don't full explain things, throws us a bone_\r\n\r\n\r\n#### Do not document default parameter values\r\n\r\nWhy? _These valuers show up in rdoc, so restating them is just a maintenance issue_\r\n\r\n\r\n#### Document the types of each attribute created with an `attr_` method\r\n\r\nWhy? _No other way to know what the types are_\r\n\r\n\r\n### Classes And Modules\r\n\r\n#### Rubydoc all classes with at least the purpose of the class\r\n\r\nWhy? _Naming is hard; documentation helps explain what a class is for_\r\n\r\n\r\n#### For non-namespaced modules, the Rubydoc should include the names and purpose of all methods that a class is expected to provide when mixing in\r\n\r\nWhy? _Because we don't have types, the user of your module needs to know what methods to implement to make the module work_\r\n\r\n\r\n#### Summarize the purpose of the class or module as the first line\r\n\r\nWhy? _This lets someone see, at a glance, what the construct is for_\r\n\r\n\r\n#### Do not start documentation with 'This class' or 'This module'\r\n\r\nWhy? _We know what kind of thing it is; just state what it does_\r\n\r\n\r\n## Testing\r\n\r\n#### Unit test methods should have three parts: Given, When, Then\r\n\r\nWhy? _This makes it clear what each section of the test is doing, which is crucial when tests get complex_\r\n\r\n```ruby\r\ndef test_something\r\n  # Given\r\n  person = Person.new(\"Dave\",38)\r\n\r\n  # When\r\n  minor = person.minor?\r\n\r\n  # Then\r\n  assert minor,\"Expected #{person.inspect} to be a minor\"\r\nend\r\n```\r\n\r\n#### For mocking, include a fourth part before 'When' so that the flow of the test is maintained\r\n\r\nWhy? _It's important to established what the mock expectations are, and thinking of it as seperate from a given helps the test read better._\r\n\r\n```ruby\r\ndef test_something\r\n  # Given\r\n  person = Person.new(\"Dave\",38)\r\n\r\n  # When the test runs, Then\r\n  AuditStats.expects(:query).returns(true)\r\n\r\n  # When\r\n  minor = person.minor?\r\n\r\n  # Then\r\n  assert minor,\"Expected #{person.inspect} to be a minor\"\r\nend\r\n```\r\n\r\n#### If your only assertion is that mock expectations are met, include a comment indicating this\r\n\r\nWhy? _It's important to let others know your intent that the mock expectations ARE the test and that you just didn't forget an assert_\r\n\r\n```ruby\r\ndef test_something\r\n  # Given\r\n  person = Person.new(\"Dave\",38)\r\n\r\n  # When the test runs, Then\r\n  PersonDAO.expects(:save).with(person)\r\n\r\n  # When\r\n  person.save!\r\n\r\n  # Then mock expectations should've been met\r\nend\r\n```\r\n\r\n#### For block-based assertions, place the code inside a lambda to preserve the structure\r\n\r\nWhy? _Again, this preserves the flow of the test_\r\n\r\n```ruby\r\ndef test_something\r\n  # Given\r\n  name = 'Dave'\r\n\r\n  # When\r\n  code = lambda { Person.create(:name => name) }\r\n\r\n  # Then\r\n  assert_difference('Person',&code)\r\n  assert_equal name,Person.last.name\r\nend\r\n```\r\n\r\n#### Avoid literals that aren't relevant to the test; abstract into a `any` method or `some` method, e.g. `some_int`\r\n\r\nWhy? _Tests littered with literals can be very hard to follow; if the only literals in the test are those specific to *this* test, it becomes very clear what's being tested._\r\n\r\n\r\n#### For literals that *are* relevant to the test, do not repeat them in a test\r\n\r\nWhy? _Just like magic strings are bad in real code, they are in test code.  Plus it codifies that the values are the same by design and not just by happenstance_\r\n\r\n\r\n#### Extract setup and assertions that are the same *by design* into helper methods\r\n\r\nWhy? _If you are running a different test under the exact same conditions as another test, extract that duplicative code into a helper.  Similarly, if you are conducting a different test that should have the same outcome, extract those assertions to a helper._\r\n\r\n\r\n#### Leave repeated code that is the same *by happenstance*\r\n\r\nWhy? _This sort of duplication is OK becauser they code is only the same by happenstance, and may diverge as the code matures.  By leaving it seperate, it's easier to change_\r\n\r\n\r\n#### The 'When' part of your tests should ideally use the public API of the class under test.\r\n\r\nWhy? _Some RSpec constructs assert things about the class under test without calling its public API, e.g. `person.should be_valid`.  This goes against the spirit of TDD, and requires the reader to make a mental transaction between the testing DSL and the class' method, with no discernable benefit._\r\n\r\n\r\n#### If you need to sanity-check your setup in the 'Given', use `raise` instead of `assert`\r\n\r\nWhy? _`raise` will mark your test as erroneous, not failed, as that is the case when the setup conditions for the test aren't correct.  Better yet, don't use brittle globally-shared test fixtures or factories._\r\n\r\n\r\n#### Avoid fixtures, factories, or other globally-shared setup data.\r\n\r\nWhy? _As an app matures, the fixtures or factories become incredibly brittle and hard to modify or understand.  It also places key elements of your test setup far away from the test itself, making it hard to understand any given test._\r\n\r\n\r\n## Rails\r\n\r\n### Controllers\r\n\r\n#### There should be very few `if` statements; controllers should be as dumb as possible\r\n\r\nWhy? _`if` statements usually imply business logic, which does not belong in controllers.  The logic in the controller should be mainly concerned with send the correct response to the user._\r\n\r\n\r\n#### Avoid excessive filters, or filters that are highly conditional\r\n\r\nWhy? _When the number of filters increases, it becomes harder and harder to know what code is executing and in what order.  Further, when filters set instance variables, it becomes increasingly difficult to understand where those variables are being set, and the filters become very order-specific.  Finally, conditional filters, or filters used on only one controller method increase complexity beyond the point of utility_\r\n\r\n\r\n#### `rake routes` should be the truth, the whole truth, and nothing but the truth\r\n\r\nWhy? _By lazily creating all routes for a resource, when you only need a few to be valid, you create misleading output for newcomers, and allow valid named route methods to be created that can only fail at runtime or in production._\r\n\r\n```ruby\r\n# Wrong; our app only supports create and show\r\nresources :transactions\r\n\r\n# Right; rake routes reflects the reality of our app now\r\nresources :transactions, :only => [:create, :show]\r\n```\r\n\r\n#### Prefer exposing the exact objects views require rather than 'root' objects requiring deep traveral\r\n\r\nWhy? _When views navigate deep into object hierarchies, it becomes very difficult to understand what data the views really *do* require, and it makes refactoring anything in those object hierarchies incredibly difficult_\r\n\r\n```ruby\r\n# A view for a person's credit cards requires the person's name, and a list of last-4, type, and expiration date of cards\r\n\r\n# Wrong; the view must navigate through the person to get his credit cards and has\r\n# access to the entire person objects, which is not needed\r\ndef show\r\n  @person = Person.find(params[:person_id])\r\nend\r\n\r\n# Wrong; although the view can now access credit cards directly, it's still not clear what data\r\n# is really needed by the view\r\ndef show\r\n  @person = Person.find(params[:person_id])\r\n  @credit_cards = @person.credit_cards\r\nend\r\n\r\n# Right; the ivars represent what the view needs AND contain only what the view needs.\r\n# You may wish to use a more sophisticated \"presenter\" pattern instead of OpenStruct\r\ndef show\r\n  @person_name = Person.find(params[:person_id].full_name\r\n  @credit_cards = @person.credit_cards.map { |card|\r\n    OpenStruct.new(:last_four => card.last_four, \r\n                   :card_type => card.card_type,\r\n                   :expiration_date => [card.expiration_month,card.expiration_year].join('/'))\r\n  }\r\nend\r\n```\r\n\r\n#### Do not create ivars unless they are to be shared with the views.\r\n\r\nWhy? _Using instance variables to avoid passing parameters is lazy and creates complex and hard-to-understand code.  In a controller, instance variables are special: they represent the data passed to the views, and that's all they should be used for._\r\n\r\n\r\n### Active Record\r\n\r\n#### Do not use hooks\r\n\r\nWhy? _Hooks make your models very hard to use in different ways, and lock them to business rules that are likely not all that hard and fast.  They also make testing very difficult, as it becomes harder and harder to set up the correct state using objects that have excessive hooks on them._\r\n\r\n```ruby\r\n# Wrong; we've hidden business logic behind a simple CRUD operation\r\nclass Person < ActiveRecord::Base\r\n  after_save :update_facebook\r\n\r\nprivate\r\n\r\n  def update_facebook\r\n    # send Facebook some status update \r\n  end\r\nend\r\n\r\n# Better; we have a method that says what it does\r\nclass Person < ActiveRecord::Base\r\n\r\n  def save_and_update_facebook\r\n    if save\r\n      # Send Facebook some status update\r\n    end\r\n  end\r\nend\r\n```\r\n\r\n#### Validations should not be conditional\r\n\r\nWhy? _Validations that are not always applicable make it very hard to modify objects and enhance them, because it becomes increasingly difficult tor understand what a valid objects really is.  Further, it becomes very difficult to set up objects in a particular state for a given test if there are a lot of conditonal validations_\r\n\r\n\r\n#### Use database constraints to enforce valid data in the database\r\n\r\nWhy? _The database is the only place that can truly ensure various constraints, such as uniqueness.  Constraints are incredibly useful for making sure that, regardless of bugs in your code, your data will be clean._\r\n\r\n\r\n#### AR objects should be as dumb as possible; only derived values should be new methods\r\n\r\nWhy? _It may be tempting to add business logic to your models.  This instanvce violates the single responsiblity principal, but it also makes the classes harder and harder to understand, test, and modify.  Treat your modesl as dumb structs with persistence, and put all other concerns on other classes.  Do not just mix in a bunch of modules._\r\n\r\n\r\n","tagline":"My Personal Ruby Style Guide","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}