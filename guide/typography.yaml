---
- :rule: "Code readability is more important that diff readability"
  :why: "Although formatting changes in diffs can make them harder to understand, the code is more likely to be read in its complete state, and so your typography choices should favor that state"
- :rule: "2-space indent"
  :why: "this is standard across almost all Ruby code"
- :rule: "Hashes created with hashrockets (=>) should be formatted with the keys left-aligned, and hashrockets right aligned to the values"
  :why: "Although it's extra work to maintain and can break diffs, I feel that the clarity and readability of this structure is worth it - the code is read many more times than changed"
  :example: |
    # Wrong; no visual order
    hash = {
      "first_name" => "Dave",
      "last_name" => "Copeland",
      "town" => "DC",
      "country" => "US",
    }

    # Right; easy to read
    hash = {
      "first_name" => "Dave",
      "last_name"  => "Copeland",
      "town"       => "DC",
      "country"    => "US",
    }
- :rule: "Hashes created in the 1.9 style should have their keys right-alighted so that the colons for a single, vertical line"
  :why: "This makes the hash options easy to read, and creates a nice visual separation between keys and values"
  :example: |
    # Wrong; no visual order, hard to read
    options = {
      first_name: "Dave",
      last_name: "Copeland",
      town: "DC",
      country: "US",
    }

    # Right; easy to read and format
    options = {
      first_name: "Dave",
       last_name: "Copeland",
            town: "DC",
         country: "US",
    }
- :rule: "For bulk assignments (3 or more assignments in a row), align the equals signs, with the left-hand side left-aligned"
  :why: "Makes the big section of assignments easier to read and to distinguish from the rest of a routine"
  :example: |
    def initialize(first_name, last_name, town, country)
      # Wrong, harder to read
      @first_name = first_name
      @last_name = first_name
      @town = town
      @country = country
    end

    def initialize(first_name, last_name, town, country)
      # Right, easier to read
      @first_name = first_name
      @last_name  = first_name
      @town       = town
      @country    = country
    end
- :rule: "When you have a large block of assignments that are using a mix of literals, local variables, and names with sigils (ivars, class ivars, or globals), consider aligning names rather than symbols"
  :why: "Aligning names allows you to easily read for content, because your syntax highlighting editor can color-code symbols to allow you to later read for sources of data"
  :example: |
    # Obviously terrible
    attrs[:first_name] = @first_name
    attrs[:last_name] = last_name
    attrs[:town] = @@default_town
    attrs[:country] = $only_country_we_support
    attrs[:title] = "Mister"

    # Better, but not the best
    attrs[:first_name] = @first_name
    attrs[:last_name]  = last_name
    attrs[:town]       = @@default_town
    attrs[:country]    = $only_country_we_support
    attrs[:title]      = "Mister"

    # MUCH better - names are aligned for readibility, but we aren't 
    # obscuring the source of these symbols
    attrs[:first_name] =  @first_name
    attrs[:last_name]  =   last_name
    attrs[:town]       = @@default_town
    attrs[:country]    =  $only_country_we_support
    attrs[:title]      =  "Mister"

- :rule: "Align open braces in a block of RSpec lets"
  :why: "Visually distinguishes the set of variables relevant to the tests"
  :example: |
    context "when we have all the data" do
      # Wrong; harder to read
      let(:first_name) { "Dave" }
      let(:last_name) { "Copeland" }
      let(:town) { "DC" }
      let(:country) { "USA" }

      # Right; easy to read and modify
      let(:first_name) { "Dave" }
      let(:last_name)  { "Copeland" }
      let(:town)       { "DC" }
      let(:country)    { "USA" }
    end
- :rule: "For blocks of assertions in tests, align the expected and received to ensure visual alignment"
  :why: "This creates a nice, readable list of assertions about your code"
  :example: |
    # Test::Unit style
    assert_equal     "Dave",     person.first_name
    assert_equal     "Copeland", person.last_name
    assert_equal     "DC",       person.town
    assert_not_equal "UK",       person.country

    # RSpec should style
    person.first_name.should  == "Dave"
    person.last_name.should   == "Copeland"
    person.town.should        == "DC"
    person.country.should_not == "UK"

    # RSpec expect style
    expect(person.first_name).to  eq("Dave")
    expect(person.last_name).to   eq("Copeland")
    expect(person.town).to        eq("DC")
    expect(person.country).not_to eq("UK")
- :rule: "Avoid single-line methods"
  :why: "Single-line methods are harder to change when the method needs an additional line"
- :rule: "Keep line lengths 80 characters or less unless doing so negatively impacts readability (e.g. for large string literals)"
  :why: "Excessively long lines can be very difficult to read and understand; a low line length encourages keeping things simple"
- :rule: "For 'options-hash' calls, align keys across multiple lines, one per line, e.g."
  :why: "This makes it easier to read and modify the options sent to the method"
  :example: |
    # OK; options are lined up
    some_call(non_option1,non_option2,foo: "bar",
                                     blah: "quux",
                                      bar: 42)
    # Better; distinction between args and options is more apparent
    some_call(non_option1, non_option2,
              foo: "bar",
             blah: "quux",
              bar: 42)
- :rule: "Literal lists should be on one line or one element per line, depending on length"
  :why: "Two-dimensional data is hard to read and modify."
- :rule: "`protected` and `private` should be aligned with `class`"
  :why: "Creates a visual distinction between the sections of code"
  :example: |
    class SomeClass

      def public_method
      end

    protected

      def protected_method
      end

    private

      def private_method
      end
    end
- :rule: "`protected` and `private` are surrounded by newlines"
  :why: "Visually sets them off"
- :rule: "A newline after `class` or `module`"
  :why: "Visual clearance"
- :rule: "A newline after `end` unless it's the string of `end`s for the end of the class/module"
  :why: "I don't get much value from visual clearance for the end blocks that 'close' a class or module"
- :rule: "Class methods should be defined via `def self.class_name` and not inside a `class << self`"
  :why: "This reduces errors caused by moving methods around, and also doesn't require you to scroll up in the class to determine what type of method it is; you can see it instantly"
- :rule: "When using the return value of an `if` expression, indent the `else` and `end` with the `if`:"
  :why: "This makes it very clear that you are using `if..else..end` as a complex expression and not as a control structure"
  :example: |
    # Wrong
    result = if something?
      :foo
    else
      :bar
    end

    # Right
    result = if something?
                :foo
             else
                :bar
             end
